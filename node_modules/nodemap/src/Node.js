import uid from "shortid";
import { EventEmitter } from "events";
const del = Symbol.for("delete");

export default class _Node extends EventEmitter {

    constructor(data = {}) {
        super();
        this._id = data.id || uid();
        this._data = data;
        this._parentId = undefined;
        this._childIds = [];
        this._layer = 0;
        this._rootId = undefined;
        this._alive = true;
        this.tree.add(this);
    }

    get id() {
        return this._id;
    }

    get alive() {
        return this._alive;
    }

    get childIds() {
        return [].concat(this._childIds);
    }

    get layer() {
        return this._layer;
    }

    get rootId() {
        return this._rootId;
    }

    get parentId() {
        return this._parentId;
    }

    _aliveValidate() {
        if (!this.alive) {
            throw new Error(`id=${this.id}'s node is dead!`);
        }
    }

    addChild(childNode) {
        this._aliveValidate();
        if (childNode.tree !== this.tree) throw new Error("different tree");
        if (this.childIds.includes(childNode.id)) return this;
        childNode._link(this);
        return this;
    }

    _link(parent) {
        this._aliveValidate();
        this._rootId = parent.rootId;
        this._parentId = parent.id;
        this._layer = parent.layer + 1;
        this._rootId = parent.rootId || parent.id;
        parent._childIds.push(this.id);
        parent._childIds = [...new Set(parent._childIds)];
        this._childIds.forEach(id => this.get(id)._link(this));
    }

    createChild(data) {
        this._aliveValidate();
        const child = new this.constructor(data);
        this.addChild(child);
        return child;
    }

    remove(id) {
        this._aliveValidate();
        if (id) {
            let node = this.get(id);
            if (node)
                node.remove();
        } else {
            this._allDeepChildIds.forEach(id => {
                let n = this.get(id)
                if (n)
                    n.remove();
            });
            this.tree[del](id);
            if (this.parentId) {
                let parent = this.get(this.parentId);
                let childIdsSet = new Set(parent._childIds);
                childIdsSet.delete(this.id);
                parent._childIds = [...childIdsSet];
            }
            this._layer = 0;
            this._parentId = 0;
            this._rootId = 0;
            this._alive = false;
            // this._tree = null;
        }
    }

    detach() {
        this._aliveValidate();
        this.moveTo();
    }

    moveTo(parentId) {

        this._aliveValidate();

        if (this.parentId) {
            let parent = this.get(this.parentId);
            let set = new Set(parent._childIds);
            set.delete(this.id);
            parent._childIds = [...set];
        }

        if (parentId) {
            if (this._allDeepChildIds.includes(parentId)) throw new Error("parent node can't move to child's internal")
            var parent = this.get(parentId);
            this._link(parent);
        } else {
            this._parentId = undefined;
            this._rootId = undefined;
            this._layer = 0;
            this._childIds.forEach(id => this.get(id)._link(this));
        }

    }

    get _allDeepChildIds() {
        this._aliveValidate();
        let ids = [].concat(this._childIds);
        this._childIds.forEach(id => ids = ids.concat(this.get(id).allChilds))
        return ids;
    }

    get(id) {
        return this.tree.get(id);
    }

    data(k, v) {
        if (k && typeof k === "string" && !v) {
            return this._data[k];
        } else if (k && typeof k === "object" && !v) {
            this._aliveValidate();
            this._data = { ...this._data, ...k };
            this.emit("change");
        } else if (k && v) {
            this._aliveValidate();
            this._data[k] = v;
            this.emit("change");
        } else {
            return JSON.parse(JSON.stringify(this._data));
        }
    }

    static parse(json) {
        let {
            id,
            data,
            parentId,
            childIds,
            layer,
            rootId,
            alive,
        } = JSON.parse(JSON.stringify(json));

        let n = {
            id,
            data,
            parentId,
            childIds,
            layer,
            rootId,
            alive,
        }

        n.__proto__ = this.prototype;
        return n;
    }

    get json() {
        return this.constructor.toJSON(this);
    }

    static toJSON(o) {
        return JSON.parse(JSON.stringify(
            {
                id: o.id,
                data: o._data,
                parentId: o._parentId,
                childIds: o._childIds,
                layer: o._layer,
                rootId: o._rootId,
                alive: o._alive
            }
        ));
    }

    get tree() {
        if (!this._tree)
            throw new Error("sub class must implements _tree");

        return this._tree;
    }

    static get tree() {
        return this.prototype._tree;
    }

}
